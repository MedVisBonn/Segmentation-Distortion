class MeanDistSamplesDetector(nn.Module):
    """
    Evaluation class for OOD and ESCE tasks based on VAEs.
    """
    
    def __init__(
        self,
        model: nn.Module, 
        n_samples: int,
        net_out: str,
        valid_loader: DataLoader,
        criterion: nn.Module, # e.g. DiceScoreCalgary()
        device: str = 'cuda:0',
        method: str = 'vae'
    ):
        super().__init__()
        self.device = device
        self.model = model.to(device)
        self.net_out  = net_out
        # Remove trainiung hooks, add evaluation hooks
        self.model.remove_all_hooks()        
        self.model.hook_transformations(self.model.transformations,
                                        n_samples=n_samples)
        
        self.model.eval()
        self.model.freeze_seg_model()
        
        self.valid_loader = valid_loader
        self.criterion = criterion
        self.umap_generator = UMapGenerator(method=method,
                                            net_out=net_out)
        
    @torch.no_grad()
    def testset_ood_detection(self, test_loader: DataLoader) -> Dict[str, torch.Tensor]:
        if not hasattr(self, 'threshold'):
            valid_dists = []
            for batch in self.valid_loader:
                input_ = batch['input'].to(0)
                
                if self.net_out == 'calgary':
                    net_out_volume = []
                    umap_volume  = []

                    for input_chunk in input_:
                        umap, net_out = self.forward(input_chunk.unsqueeze(0).to(self.device))
                        net_out_volume.append(net_out[:1].detach().cpu())
                        umap_volume.append(umap)

                    net_out = torch.cat(net_out_volume, dim=0)
                    umap = torch.cat(umap_volume, dim=0)
                    
                if self.net_out == 'mms':
                    umap, net_out = self.forward(input_.to(self.device))
                score = torch.norm(umap).cpu()
                valid_dists.append(score)
                    
            self.threshold = 0
            valid_dists = torch.tensor(valid_dists)
            self.threshold = torch.sort(valid_dists)[0][len(valid_dists) - (len(valid_dists) // 20) - 1]
        
        test_dists = []
        for batch in test_loader:
            input_ = batch['input']

            if self.net_out == 'calgary':
                net_out_volume = []
                umap_volume  = []

                for input_chunk in input_:
                    umap, net_out = self.forward(input_chunk.unsqueeze(0).to(self.device))
                    net_out_volume.append(net_out[:1].detach().cpu())
                    umap_volume.append(umap)

                net_out = torch.cat(net_out_volume, dim=0)
                umap = torch.cat(umap_volume, dim=0)

            if self.net_out == 'mms':
                umap, net_out = self.forward(input_.to(self.device))

            score = torch.norm(umap).cpu()
            test_dists.append(score)
            
        test_dists = torch.tensor(test_dists).cpu()
        accuracy = (test_dists > self.threshold).sum() / len(test_dists)
        
        return accuracy    
        
    
    @torch.no_grad()
    def testset_correlation(self, test_loader: DataLoader) -> Dict[str, torch.Tensor]:
        corr_coeff = SpearmanCorrCoef()
        losses = []
        for batch in test_loader:
            input_ = batch['input']
            target = batch['target']
            
            if self.net_out == 'calgary':
                net_out_volume = []
                umap_volume  = []

                for input_chunk in input_:
                    umap, net_out = self.forward(input_chunk.unsqueeze(0).to(self.device))
                    net_out_volume.append(net_out[:1].detach().cpu())
                    umap_volume.append(umap)
                    
                net_out = torch.cat(net_out_volume, dim=0)
                umap = torch.cat(umap_volume, dim=0)
            
            if self.net_out == 'mms':
                target[target == -1] = 0
                # convert to one-hot encoding
                target = F.one_hot(target.long(), num_classes=4).squeeze(1).permute(0,3,1,2)
                umap, net_out = self.forward(input_.to(self.device))
            
            
            loss = self.criterion(net_out, target)
            
            loss = loss.mean().float()
                    
            score = torch.norm(umap)
            losses.append(1-loss.view(1))
            corr_coeff.update(score.cpu(), 1-loss)
            
        return corr_coeff

    
    @torch.no_grad()  
    def forward(self, input_: torch.Tensor) -> torch.Tensor:
        net_out = self.model(input_).cpu()
        umap    = self.umap_generator(net_out).cpu()
        return umap, net_out[:1]
    